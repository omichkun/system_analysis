# Описание

## Общее описание схемы

Все схемы лежат в документе 1hw.drawio. Открывать его с помощью https://app.diagrams.net/ или, для локального скачивания – https://github.com/jgraph/drawio-desktop/releases/tag/v21.2.8 


Схема содержит в себе несколько вкладок: 

- Event Storming - реализация Event Storming'а 
- Contexts with Relations – модель данных приложения
- Contexts and Services – схема распределения контекстов по сервисам
- Implementation – итоговая схема реализации с конкретными инструментами


## Event Storming

1. В моей реализации подразумевал, что в одном заказе может быть несколько услуг (например, потыгыдыкать, поцарапать диван и столкнуть кружки с пианино можно сделать в рамках одного заказа). От этого и отталкивался в дальнейшем.
1. Матчинг вынес в отдельный контекст, так как, судя по описанию, его разрабатывает вообще отдельная команда, и также это является еще чуть ли не Core Domain для всего приложения. 
1. Конфигурирование вынес в отдельный контекст, потому что идейно не придумал, куда это можно добавить. Сейчас там только конфигурирование типов задач
1. В конфигурирование еще вынес возможность подкорректировать/добавить данных о воркере и клиенте, хоть этого не было в ТЗ, но подумал, что это логичное решение. 


## Contexts with Relations

1. Контекст конфигурирования сделал владельцем данных о типах услуги. В нем менеджер изначально создает новые типы услуг. 
1. В контексте клиента данные выглядят следующим образом. ServiceType - это описание услуги, что она из себя представляет, а Service – это уже конкретная услуга, которая будет оказываться в составе заказа со  всякой актуальной информацией. По сути Service – это связывающая таблица в отношении многие-ко-многим между заказом и услугами.
1. Клиентский контекст решил сделать владельцем данных о клиенте (в нем он изначально помещает информацию о себе)
1. Из условия не до конца понятно было как работает маппинг. Используются ли в нем данные о текущих услугах заказа или только результаты старых заказов и данные воркера + клиента. Предположил что не используются. 


## Contexts and Services

1. В итоге сделал монолит с четырьмя сервисов: 
    - Main App – основной монолит 
    - Billing service – сервис биллинга
    - Testing service – сервис тестирования и добавления новых воркеров
    - Matching service – сервис матчинга
    - Notifications service – сервис уведомлений
1. Все основные взаимодействия между контекстами в итоге остались внутри монолита.
1. Биллинг в отдельном сервисе, потому что видится, что это одна из самых нагруженных частей системы. Там постоянно происходят транзакции (IO-нагрузка), забирается статистика по транзакциям, вычисляется стоимость (CPU-нагрузка) итд. Для того, чтоб не грузить основную БД, выносимв отдельный сервис со своей БД. 
1. Тестирование вынес в отдельный сервис для отказоустойчивости, так как в ТЗ указано, что там будет довольно высокая нагрузка + там возможен ДДОС конкурентов.
1. Matching service – вынес в отдельный сервис, потому что матчингом занимается отдельная команда и она может часто менять требования, то есть его нужно выкатывать независимо для более высокого availability и низкого Time-To-Market
1. Notifications Service – в отдельном сервисе, потому что из всех остальных удобно в этот сервис закидывать сообщения, а он уже отдельно разруливает как доставлять 

## Implementation

1. Пунктиром указаны асинхронные взаимодействия, сплошными линиями – синхронные.
1. Все отправляют данные (уведомления) в Notifications Service
1. Все асинхронные взаимодействия происходят через RabbitMQ – через него проще все это запустить, чем через кафку и нам не надо хранить логи событий. Изобразил отдельно, чтобы было понимание, что он в принципе существует, но стрелки не стал через него вести, чтобы схема была более "чистой".
1. Из Main App в биллинг уходит один синхронный запрос – это предварительный подсчет стоимости, который нам нужен прям вот сейчас. Остальные запросы – отправка транзакций, асинхронные. 